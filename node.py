import json
import socket
import threading
import time

import logging

BUFF_SIZE = 2 ** 20  # 1 MB buffer
MAX_CONN_TRIES = 3


class Node:
    def __init__(self, *, identifier: int, host: str, port: int,
                 next_host: str, next_port: int):
        """Constructor for node

        Args:
            identifier (int): unique identifier for node
            port (int): port to listen with socket
            next_host (str): host for the next node in the ring
            next_port (int): port for the next node in the ring
        """
        self.identifier = identifier
        self.host = host
        self.port = port
        self.next_port = next_port
        self.next_host = next_host
        self.id = identifier
        self.asking_restore = False
        self.alive = True

        self.ring_leader = None

        logging.basicConfig(format='%(asctime)s | %(message)s',
                            level=logging.INFO)
        self.logger = logging.getLogger('node_ring')
        self.setup_belt()
        self.setup_server()
        self.setup_heartbeater()
        self.setup_heartbeat_listener()

        # Start threads

        self.server_thread = threading.Thread(target=self.run_listening_server)
        self.server_thread.start()
        self.actor_thread = threading.Thread(target=self.run_actor_thread)
        self.actor_thread.start()

    def log(self, msg):
        """Wrapper for logger info"""
        self.logger.info(f'[NODE {self.id}]' + msg)

    def debug(self, msg):
        """Wrapper for logger debug"""
        self.logger.debug(f'[NODE {self.id}]' + msg)

    def setup_belt(self):
        """Setup belt to exchange messages"""
        self.messages_belt = []
        self.belt_lock = threading.Lock()
        self.messages_sem = threading.Semaphore(value=0)

    def setup_server(self):
        """Setup the server to receive messages"""
        self.server = self.create_socket()
        self.server.settimeout(3)
        self.server.bind((self.host, self.port))
        self.server.listen(5)

        self.log(
            f'Server with id {self.id} started at {self.host}:{self.port}')

    def setup_heartbeater(self):
        """Setup event to give heartbeats to next node"""
        self.heartbeat_timer = threading.Timer(
            interval=5, function=self.send_heartbeat)
        self.heartbeat_timer.start()

    def setup_heartbeat_listener(self):
        """Setup heartbeat listener to timeout and ask for retore"""
        self.prev_heartbeat_timer = threading.Timer(interval=15,
                                                    function=self.ask_restore)
        self.prev_heartbeat_timer.start()

    def ask_restore(self):
        """Ask for restore ring"""
        if not self.asking_restore:
            self.asking_restore = True
            self.log('Asking for restore')
            msg = {
                'type': 'restore',
                'host': self.host,
                'port': self.port,
                'dest': 'any',
                'src': self.id
            }

            self.send_to_next(msg)

            self.setup_heartbeat_listener()

    def send_heartbeat(self):
        """Send heartbeat to next"""
        self.debug('Sending heartbeat')
        msg = {
            'type': 'heartbeat',
            'dest': 'any',
            'src': self.id
        }

        self.send_to_next(msg)

        self.setup_heartbeater()

    def create_socket(self) -> socket.socket:
        """Create a default socket"""
        return socket.socket(family=socket.AF_INET,
                             type=socket.SOCK_STREAM)

    def run_listening_server(self):
        """Receiving messages server"""
        while self.alive:
            try:
                clientsocket, _ = self.server.accept()
            except socket.timeout:
                continue

            # Run a "producer" in other thread
            t = threading.Thread(target=self.receive_message,
                                 args=(clientsocket,))
            t.start()

        self.server.close()
        self.server.detach()
        self.log('Server shutdown')

    def receive_message(self, clientsocket):
        """Get sockets generated by server and "produce" its message"""
        raw_data = clientsocket.recv(BUFF_SIZE).decode()
        if not raw_data:
            return
        message = json.loads(raw_data)

        # Insert received message in the belt
        self.put_message_into_belt(message)

        # Increase semaphore so actor can check the belt
        self.messages_sem.release()

    def run_actor_thread(self):
        while self.alive:
            # Wait for messages in the belt
            acquired = self.messages_sem.acquire(timeout=5)
            if not acquired:
                continue

            # Get message
            self.belt_lock.acquire()
            message = self.messages_belt.pop(0)
            self.belt_lock.release()

            # Deal with the message
            self.act(message)

        self.log('Actor shutdown')

    def act(self, message):
        if 'dest' not in message:
            self.log('Message with no destiny, cannot process')
            return

        if message['dest'] not in [self.id, 'any']:
            self.send_to_next(message)

        if 'type' not in message:
            self.log('Message with not type, cannot process')
            return

        acts = {
            'start_election': self.act_start_election,
            'set_leader': self.act_set_leader,
            'election': self.act_election,
            'print': self.act_print,
            'heartbeat': self.act_receive_heartbeat,
            'restore': self.act_restore,
            'abort': self.act_abort
        }

        try:
            acts[message['type']](message)

        except KeyError:
            self.log('Invalid message type: %s' % message['type'])

    def act_start_election(self, message: dict):
        self.log('Starting election')
        msg = {
            'type': 'election',
            'src': self.id,
            'dest': 'any',
            'winner': self.id
        }

        self.send_to_next(msg)

    def act_election(self, message: dict):
        self.log('Running election')
        if message['src'] == self.id:
            self.log('Selection round finished.')
            self.send_elections_result(message)
            return

        if message['winner'] < self.id:
            message['winner'] = self.id

        self.send_to_next(message)

    def act_print(self, message: dict):
        dest = f'{self.next_host}:{self.next_port}'
        self.log('Received print command. ' +
                 f'I\'m node {self.id}, I communicate with {dest} ' +
                 (f'and my leader is {self.ring_leader}'
                  if self.id != self.ring_leader
                  else f'and I\'m the leader.'))

    def act_set_leader(self, message: dict):
        if message['src'] == self.id:
            self.log('Elections finished')
            return

        self.log(f'Setting leader to {message["winner"]}')
        self.ring_leader = message['winner']

        self.send_to_next(message)

    def act_receive_heartbeat(self, message: dict):
        """Reset heartbeat listener"""
        self.debug(f'Received heartbeat from {message["src"]}')
        self.prev_heartbeat_timer.cancel()
        self.setup_heartbeat_listener()

        self.asking_restore = False

    def act_restore(self, message: dict):
        """Try to connect to the current next.

        If it does not succeed, connect to node asking for restore
        else, pass the message to the next node
        """
        self.log('Restoring ring')
        sock = self.create_socket()
        for _ in range(MAX_CONN_TRIES):
            try:
                sock.connect((self.next_host, self.next_port))
                self.send_to_next(message)
                return

            except ConnectionRefusedError:
                self.log('Failed to connect to next. Waiting...')
                time.sleep(1)
                continue

        self.log('Setting up new next, previous died')
        self.next_host = message['host']
        self.next_port = message['port']
        self.log(f'Next: {self.next_host}:{self.next_port}')

    def act_abort(self, message: dict):
        """Finish node"""
        self.prev_heartbeat_timer.cancel()
        self.heartbeat_timer.cancel()
        self.alive = False

    def send_elections_result(self, message: dict):
        """Check the winner, set on the current node and send to the next"""
        self.ring_leader = message['winner']
        self.log(f'Leader is {self.ring_leader}. Starting propagation.')

        msg = {
            'type': 'set_leader',
            'src': self.id,
            'dest': 'any',
            'winner': message['winner']
        }

        self.send_next_with_retry(msg)

    def send_next_with_retry(self, message: dict):
        """Send message to next with retry after delay.

            This function can causa a loop if the message
            cannot be sent.
        """
        if not self.alive:
            return

        sock = self.create_socket()

        try:
            sock.connect((self.next_host, self.next_port))

            serialized_msg = json.dumps(message).encode()
            sock.send(serialized_msg)

        except ConnectionRefusedError:
            dest = f'{self.next_host}:{self.next_port}'
            self.log(f'Unable to connect to {dest}. Starting retry timer.')
            t = threading.Timer(30, self.send_next_with_retry,
                                args=(message,))
            t.start()

    def put_message_into_belt(self, message: dict):
        """Acquire lock, put message into belt, and release"""
        self.belt_lock.acquire()
        self.messages_belt.append(message)
        self.belt_lock.release()

    def send_to_next(self, message: dict):
        sock = self.create_socket()

        try:
            sock.connect((self.next_host, self.next_port))

            serialized_msg = json.dumps(message).encode()
            sock.send(serialized_msg)

        except ConnectionRefusedError:
            dest = f'{self.next_host}:{self.next_port}'
            self.log(f'Unable to connect to {dest}. Is it alive?')
            self.log('Re-queueing the message.')
            self.put_message_into_belt(message)
